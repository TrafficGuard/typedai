import { randomUUID } from 'node:crypto';
import chai, { expect } from 'chai';
import chaiAsPromised from 'chai-as-promised';
import type sinon from 'sinon';
import type { VibePreset, VibeSession } from '#shared/model/vibe.model';
import type { VibeRepository } from '#vibe/vibeRepository';

chai.use(chaiAsPromised);

// Helper to create mock session data
const createMockSession = (userId: string, overrides: Partial<VibeSession> = {}): VibeSession => {
	const id = overrides.id ?? randomUUID();
	const now = Date.now();
	return {
		id: id,
		userId: userId,
		title: `Test Session ${id.substring(0, 4)}`,
		instructions: 'Test instructions',
		repositorySource: 'local',
		repositoryId: '/test/repo',
		targetBranch: 'main',
		workingBranch: `vibe/${id.substring(0, 8)}`,
		createWorkingBranch: true,
		useSharedRepos: false,
		status: 'initializing',
		createdAt: now,
		updatedAt: now,
		lastAgentActivity: now,
		error: null,
		...overrides, // Apply overrides, including potential timestamp overrides
	};
};

// Helper to create mock preset data
const createMockPreset = (userId: string, overrides: Partial<VibePreset> = {}): VibePreset => {
	const id = overrides.id ?? randomUUID();
	const now = Date.now();
	return {
		id: id,
		userId: userId,
		name: `Test Preset ${id.substring(0, 4)}`,
		config: {
			repositorySource: 'github',
			repositoryId: 'owner/repo',
			targetBranch: 'develop',
			workingBranch: 'vibe/feature-branch',
			createWorkingBranch: true,
			useSharedRepos: true,
		},
		createdAt: now,
		updatedAt: now,
		...overrides,
	};
};

import type { User } from '#shared/model/user.model';

export function runVibeRepositoryTests(
	createRepository: () => VibeRepository,
	beforeEachHook: () => Promise<void> | void,
	afterEachHook: () => Promise<void> | void,
	// Removed parameters for currentUserStub and user objects
) {
	let repo: VibeRepository;
	// Define fixed user IDs for testing consistency
	const testUserId = 'test-user-repo-tests';
	const otherUserId = 'other-user-repo-tests';
	const userWithNoItemsId = 'user-with-no-items'; // For empty list tests

	beforeEach(async () => {
		await beforeEachHook(); // Run implementation-specific setup (e.g., clear DB/memory)
		repo = createRepository();
	});

	afterEach(async () => {
		// sinon.restore(); // Removed: Stub restoration is handled by the calling test file's setup
		await afterEachHook(); // Run implementation-specific teardown
	});

	describe('VibeSession CRUD', () => {
		it('should create a new session and retrieve it', async () => {
			const sessionData = createMockSession(testUserId);
			const sessionId = await repo.createVibeSession(sessionData);
			expect(sessionId).to.equal(sessionData.id);

			const retrievedSession = await repo.getVibeSession(testUserId, sessionId);
			expect(retrievedSession).to.not.be.null;
			// Compare essential fields, allow timestamps to differ slightly if generated by DB
			expect(retrievedSession?.id).to.equal(sessionData.id);
			expect(retrievedSession?.userId).to.equal(testUserId);
			expect(retrievedSession?.title).to.equal(sessionData.title);
			expect(retrievedSession?.status).to.equal('initializing');
			expect(retrievedSession?.createdAt).to.be.a('number');
		});

		it('should return null when retrieving a non-existent session', async () => {
			const nonExistentId = randomUUID();
			const retrievedSession = await repo.getVibeSession(testUserId, nonExistentId);
			expect(retrievedSession).to.be.null;
		});

		it('should return null when retrieving a session belonging to another user', async () => {
			const sessionData = createMockSession(otherUserId);
			const sessionId = await repo.createVibeSession(sessionData);

			const retrievedSession = await repo.getVibeSession(testUserId, sessionId);
			expect(retrievedSession).to.be.null;
		});

		it.skip('should list sessions for a user, ordered by updatedAt descending', async () => {
			const session1 = createMockSession(testUserId, { createdAt: Date.now() - 5000, updatedAt: Date.now() - 2000 });
			const session2 = createMockSession(testUserId, { createdAt: Date.now() - 6000, updatedAt: Date.now() - 1000 }); // Newer update with older creation
			const sessionOtherUser = createMockSession(otherUserId);

			await repo.createVibeSession(session1);
			await repo.createVibeSession(session2);
			await repo.createVibeSession(sessionOtherUser);

			const userSessions = await repo.listVibeSessions(testUserId);
			expect(userSessions).to.be.an('array').with.lengthOf(2);
			expect(userSessions[0].id).to.equal(session2.id); // Newest first
			expect(userSessions[1].id).to.equal(session1.id);
		});

		it('should return an empty array when listing sessions for a user with no sessions', async () => {
			// No need to stub currentUser, just call list with the specific ID
			const userSessions = await repo.listVibeSessions(userWithNoItemsId);
			expect(userSessions).to.be.an('array').that.is.empty;
		});

		it('should update an existing session', async () => {
			const originalSession = createMockSession(testUserId);
			const sessionId = await repo.createVibeSession(originalSession);
			const originalUpdateTimestamp = (await repo.getVibeSession(testUserId, sessionId))?.updatedAt;

			// Ensure timestamp can change
			await new Promise((resolve) => setTimeout(resolve, 5));

			const updates: Partial<VibeSession> = {
				title: 'Updated Title',
				status: 'design_review',
				error: 'An error occurred',
			};
			await repo.updateVibeSession(testUserId, sessionId, updates);

			const updatedSession = await repo.getVibeSession(testUserId, sessionId);
			expect(updatedSession).to.not.be.null;
			expect(updatedSession?.title).to.equal(updates.title);
			expect(updatedSession?.status).to.equal(updates.status);
			expect(updatedSession?.error).to.equal(updates.error);
			expect(updatedSession?.instructions).to.equal(originalSession.instructions); // Check unchanged field
			expect(updatedSession?.updatedAt).to.be.a('number');
			// Check if timestamp actually updated (might be equal in fast in-memory tests)
			if (originalUpdateTimestamp) {
				expect(updatedSession?.updatedAt).to.be.greaterThanOrEqual(originalUpdateTimestamp);
			}
		});

		it('should throw an error when updating a non-existent session', async () => {
			const nonExistentId = randomUUID();
			const updates = { title: 'Update Fail' };
			await expect(repo.updateVibeSession(testUserId, nonExistentId, updates)).to.be.rejectedWith(/not found/i);
		});

		it('should throw an error when updating a session belonging to another user', async () => {
			const sessionData = createMockSession(otherUserId);
			const sessionId = await repo.createVibeSession(sessionData);
			const updates = { title: 'Update Fail Other User' };
			await expect(repo.updateVibeSession(testUserId, sessionId, updates)).to.be.rejectedWith(/not found|authorized/i);
		});

		it('should delete an existing session', async () => {
			const sessionData = createMockSession(testUserId);
			const sessionId = await repo.createVibeSession(sessionData);

			let retrieved = await repo.getVibeSession(testUserId, sessionId);
			expect(retrieved).to.not.be.null;

			await repo.deleteVibeSession(testUserId, sessionId);

			retrieved = await repo.getVibeSession(testUserId, sessionId);
			expect(retrieved).to.be.null;
		});

		it('should not throw an error when deleting a non-existent session', async () => {
			const nonExistentId = randomUUID();
			await expect(repo.deleteVibeSession(testUserId, nonExistentId)).to.not.be.rejected;
		});

		it('should not delete a session belonging to another user', async () => {
			const sessionData = createMockSession(otherUserId);
			const sessionId = await repo.createVibeSession(sessionData);

			// Attempt delete as testUserId
			await repo.deleteVibeSession(testUserId, sessionId);

			// Verify session still exists for otherUserId by calling getVibeSession with otherUserId
			const retrieved = await repo.getVibeSession(otherUserId, sessionId);
			expect(retrieved).to.not.be.null;
		});
	});

	describe('VibePreset CRUD', () => {
		it('should create a new preset and retrieve it', async () => {
			const presetData = createMockPreset(testUserId);
			const presetId = await repo.saveVibePreset(presetData);
			expect(presetId).to.equal(presetData.id);

			// Need to list and find, as there's no getPresetById
			const userPresets = await repo.listVibePresets(testUserId);
			const retrievedPreset = userPresets.find((p) => p.id === presetId);

			expect(retrievedPreset).to.not.be.undefined;
			expect(retrievedPreset?.id).to.equal(presetData.id);
			expect(retrievedPreset?.userId).to.equal(testUserId);
			expect(retrievedPreset?.name).to.equal(presetData.name);
			expect(retrievedPreset?.config).to.deep.equal(presetData.config);
			expect(retrievedPreset?.createdAt).to.be.a('number');
		});

		it('should list presets for a user, ordered by createdAt descending', async () => {
			const preset1 = createMockPreset(testUserId, { createdAt: Date.now() - 2000 });
			const preset2 = createMockPreset(testUserId, { createdAt: Date.now() - 1000 }); // Newer
			const presetOtherUser = createMockPreset(otherUserId);

			await repo.saveVibePreset(preset1);
			await repo.saveVibePreset(preset2);
			// Save otherUser's preset directly, userId is in the object
			await repo.saveVibePreset(presetOtherUser);
			// No need to switch context, just list for testUserId
			const userPresets = await repo.listVibePresets(testUserId);
			expect(userPresets).to.be.an('array').with.lengthOf(2);
			expect(userPresets[0].id).to.equal(preset2.id); // Newest first
			expect(userPresets[1].id).to.equal(preset1.id);
		});

		it('should return an empty array when listing presets for a user with no presets', async () => {
			// No need to stub currentUser, just call list with the specific ID
			const userPresets = await repo.listVibePresets(userWithNoItemsId);
			expect(userPresets).to.be.an('array').that.is.empty;
		});

		it('should delete an existing preset', async () => {
			const presetData = createMockPreset(testUserId);
			const presetId = await repo.saveVibePreset(presetData);

			let userPresets = await repo.listVibePresets(testUserId);
			expect(userPresets.some((p) => p.id === presetId)).to.be.true;

			await repo.deleteVibePreset(testUserId, presetId);

			userPresets = await repo.listVibePresets(testUserId);
			expect(userPresets.some((p) => p.id === presetId)).to.be.false;
		});

		it('should not throw an error when deleting a non-existent preset', async () => {
			const nonExistentId = randomUUID();
			await expect(repo.deleteVibePreset(testUserId, nonExistentId)).to.not.be.rejected;
		});

		it('should not delete a preset belonging to another user', async () => {
			const presetData = createMockPreset(otherUserId);
			// Save otherUser's preset directly
			const presetId = await repo.saveVibePreset(presetData);
			// No need to switch context for delete attempt

			// Attempt delete as testUserId
			await repo.deleteVibePreset(testUserId, presetId);

			// Verify preset still exists for otherUserId by listing their presets
			const otherUserPresets = await repo.listVibePresets(otherUserId);
			expect(otherUserPresets.some((p) => p.id === presetId)).to.be.true;
		});
	});
}
