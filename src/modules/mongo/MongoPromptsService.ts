import { type Collection, type Db, ObjectId, MongoClient } from 'mongodb'; // MongoClient import moved for consistency, but will be removed
import { logger } from '#o11y/logger';
import type { PromptsService } from '#prompts/promptsService';
import type { CallSettings, LlmMessage, Prompt, PromptPreview } from '#shared/prompts/prompts.model';

// Interface for the document stored in the 'prompts' collection (main prompt metadata)
interface MongoPromptDoc {
	_id: ObjectId; // Auto-generated by MongoDB, will be used as prompt.id
	userId: string;
	latestRevisionId: number;
	// Denormalized fields from the latest revision for preview (similar to PromptPreview)
	name: string;
	appId?: string | null;
	tags: string[];
	parentId?: string | null;
	options: CallSettings; // Denormalized from latest revision's settings
	createdAt: Date;
	updatedAt: Date;
}

// Interface for the document stored in the 'promptRevisions' collection
interface MongoRevisionDoc {
	_id: ObjectId; // Auto-generated by MongoDB
	promptId: ObjectId; // Foreign key to MongoPromptDoc._id
	revisionId: number;
	userId: string;
	// Revision-specific content
	name: string;
	appId?: string | null;
	tags: string[];
	parentId?: string | null;
	messages: LlmMessage[];
	options: CallSettings; // Actual settings for this revision
	createdAt: Date;
}

export class MongoPromptsService implements PromptsService {
	private promptsCollectionName: string;
	private revisionsCollectionName: string;
	private client: MongoClient; // Keep for session management, though db is now injected

	constructor(private db: Db) {
		// Initialize client for session management, assuming it's derived or passed similarly if needed
		// For now, let's assume the db's client is accessible or a new one is created for transactions
		// This might need refinement based on how transactions are managed with an injected Db
		this.client = db.client;
		this.promptsCollectionName = 'prompts';
		this.revisionsCollectionName = 'promptRevisions';
	}

	private getPromptsCollection(): Collection<MongoPromptDoc> {
		return this.db.collection<MongoPromptDoc>(this.promptsCollectionName);
	}

	private getRevisionsCollection(): Collection<MongoRevisionDoc> {
		return this.db.collection<MongoRevisionDoc>(this.revisionsCollectionName);
	}

	private _toPrompt(promptDocIdAsObjectId: ObjectId, revisionDoc: MongoRevisionDoc): Prompt {
		return {
			id: promptDocIdAsObjectId.toHexString(), // Convert ObjectId to string for the Prompt model
			userId: revisionDoc.userId,
			parentId: revisionDoc.parentId === null ? undefined : revisionDoc.parentId,
			revisionId: revisionDoc.revisionId,
			name: revisionDoc.name,
			appId: revisionDoc.appId === null ? undefined : revisionDoc.appId,
			tags: revisionDoc.tags,
			messages: revisionDoc.messages,
			settings: revisionDoc.options,
		};
	}

	private _toPromptPreview(promptDoc: MongoPromptDoc): PromptPreview {
		return {
			id: promptDoc._id.toHexString(),
			userId: promptDoc.userId,
			parentId: promptDoc.parentId === null ? undefined : promptDoc.parentId,
			revisionId: promptDoc.latestRevisionId,
			name: promptDoc.name,
			appId: promptDoc.appId === null ? undefined : promptDoc.appId,
			tags: promptDoc.tags,
			settings: promptDoc.options, // These are denormalized from the latest revision
		};
	}

	async getPrompt(promptId: string, userId: string): Promise<Prompt | null> {
		const promptsCollection = this.getPromptsCollection();
		const revisionsCollection = this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format: ${promptId}`, error);
			return null; // Invalid ID format
		}

		const promptDoc = await promptsCollection.findOne({ _id: promptObjectId });

		if (!promptDoc) {
			return null;
		}

		if (promptDoc.userId !== userId) {
			logger.warn(`Unauthorized access attempt for prompt ${promptId} by user ${userId}`);
			return null;
		}

		const revisionDoc = await revisionsCollection.findOne({ promptId: promptDoc._id, revisionId: promptDoc.latestRevisionId });

		if (!revisionDoc) {
			logger.error(`Data inconsistency: Latest revision ${promptDoc.latestRevisionId} for prompt ${promptId} not found.`);
			return null;
		}

		return this._toPrompt(promptDoc._id, revisionDoc);
	}

	async getPromptVersion(promptId: string, revisionId: number, userId: string): Promise<Prompt | null> {
		const promptsCollection = this.getPromptsCollection();
		const revisionsCollection = this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format for getPromptVersion: ${promptId}`, error);
			return null;
		}

		const promptDoc = await promptsCollection.findOne({ _id: promptObjectId });

		if (!promptDoc) {
			return null;
		}

		if (promptDoc.userId !== userId) {
			logger.warn(`Unauthorized access attempt for prompt ${promptId} version ${revisionId} by user ${userId}`);
			return null;
		}

		const revisionDoc = await revisionsCollection.findOne({ promptId: promptObjectId, revisionId: revisionId });

		if (!revisionDoc) {
			return null; // Revision not found
		}

		return this._toPrompt(promptDoc._id, revisionDoc);
	}

	async listPromptsForUser(userId: string): Promise<PromptPreview[]> {
		const promptsCollection = this.getPromptsCollection();
		const promptDocs = await promptsCollection.find({ userId: userId }).sort({ updatedAt: -1 }).toArray();

		if (!promptDocs || promptDocs.length === 0) {
			return [];
		}

		return promptDocs.map((doc) => this._toPromptPreview(doc));
	}

	async createPrompt(promptData: Omit<Prompt, 'id' | 'revisionId' | 'userId'>, userId: string): Promise<Prompt> {
		const promptsCollection = this.getPromptsCollection();
		const revisionsCollection = this.getRevisionsCollection();
		const newPromptObjectId = new ObjectId();
		const firstRevisionId = 1;
		const now = new Date();

		const mongoPromptDocData: MongoPromptDoc = {
			_id: newPromptObjectId,
			userId: userId,
			latestRevisionId: firstRevisionId,
			name: promptData.name,
			appId: promptData.appId ?? null,
			tags: promptData.tags,
			parentId: promptData.parentId ?? null,
			options: promptData.settings, // Denormalized from first revision
			createdAt: now,
			updatedAt: now,
		};

		const mongoRevisionDocData: MongoRevisionDoc = {
			_id: new ObjectId(), // New ObjectId for the revision doc itself
			promptId: newPromptObjectId,
			revisionId: firstRevisionId,
			userId: userId,
			name: promptData.name,
			appId: promptData.appId ?? null,
			tags: promptData.tags,
			parentId: promptData.parentId ?? null,
			messages: promptData.messages,
			options: promptData.settings,
			createdAt: now,
		};

		await promptsCollection.insertOne(mongoPromptDocData);
		await revisionsCollection.insertOne(mongoRevisionDocData);

		return this._toPrompt(newPromptObjectId, mongoRevisionDocData);
	}

	async updatePrompt(promptId: string, updates: Partial<Omit<Prompt, 'id' | 'userId' | 'revisionId'>>, userId: string, newVersion: boolean): Promise<Prompt> {
		const promptsCollection = this.getPromptsCollection();
		const revisionsCollection = this.getRevisionsCollection();
		let promptObjectId: ObjectId;
		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format for updatePrompt: ${promptId}`, error);
			throw new Error('Invalid prompt ID format');
		}

		const session = this.client.startSession();
		try {
			let resultPrompt: Prompt | undefined; // Variable to store the prompt to be returned

			await session.withTransaction(async () => {
				const promptDoc = await promptsCollection.findOne({ _id: promptObjectId }, { session });

				if (!promptDoc) {
					throw new Error('Prompt not found');
				}
				if (promptDoc.userId !== userId) {
					throw new Error('User not authorized');
				}

				const currentLatestRevisionId = promptDoc.latestRevisionId;
				const now = new Date();
				let finalRevisionDataForPromptObject: MongoRevisionDoc; // Holds the complete data of the revision to be returned

				if (newVersion) {
					// Create new revision
					const newRevisionId = currentLatestRevisionId + 1;
					const latestRevisionDoc = await revisionsCollection.findOne({ promptId: promptDoc._id, revisionId: currentLatestRevisionId }, { session });
					if (!latestRevisionDoc) {
						logger.error(`Data inconsistency: Latest revision ${currentLatestRevisionId} for prompt ${promptId} missing during update.`);
						throw new Error('Latest revision data missing');
					}
					const baseRevisionData = latestRevisionDoc;

					const newMongoRevisionDocData: MongoRevisionDoc = {
						_id: new ObjectId(), // New ObjectId for this revision document
						promptId: promptDoc._id, // Link to the parent prompt document
						userId: userId, // User performing the update
						revisionId: newRevisionId,
						createdAt: now, // Timestamp for this new revision
						// Apply updates, falling back to base data if not provided
						name: updates.name ?? baseRevisionData.name,
						appId: updates.appId === undefined ? baseRevisionData.appId : (updates.appId ?? null),
						parentId: updates.parentId === undefined ? baseRevisionData.parentId : (updates.parentId ?? null),
						tags: updates.tags ?? baseRevisionData.tags,
						messages: updates.messages ?? baseRevisionData.messages,
						options: updates.settings ?? baseRevisionData.options,
					};

					await revisionsCollection.insertOne(newMongoRevisionDocData, { session });
					// Update the main prompt document with new latestRevisionId and denormalized fields
					await promptsCollection.updateOne(
						{ _id: promptDoc._id },
						{
							$set: {
								latestRevisionId: newRevisionId,
								updatedAt: now,
								// Denormalize fields from the new latest revision
								name: newMongoRevisionDocData.name,
								appId: newMongoRevisionDocData.appId,
								tags: newMongoRevisionDocData.tags,
								parentId: newMongoRevisionDocData.parentId,
								options: newMongoRevisionDocData.options,
							},
						},
						{ session },
					);
					finalRevisionDataForPromptObject = newMongoRevisionDocData;
				} else {
					// Update existing latest revision
					const targetRevisionId = currentLatestRevisionId;
					const targetRevisionDoc = await revisionsCollection.findOne({ promptId: promptDoc._id, revisionId: targetRevisionId }, { session });
					if (!targetRevisionDoc) {
						logger.error(`Data inconsistency: Target revision ${targetRevisionId} for prompt ${promptId} missing during in-place update.`);
						throw new Error('Target revision data missing');
					}
					const baseRevisionData = targetRevisionDoc;

					// Fields to be updated in the existing revision document
					const updateFieldsForRevision: Partial<MongoRevisionDoc> = {
						name: updates.name ?? baseRevisionData.name,
						appId: updates.appId === undefined ? baseRevisionData.appId : (updates.appId ?? null),
						parentId: updates.parentId === undefined ? baseRevisionData.parentId : (updates.parentId ?? null),
						tags: updates.tags ?? baseRevisionData.tags,
						messages: updates.messages ?? baseRevisionData.messages,
						options: updates.settings ?? baseRevisionData.options,
					};

					await revisionsCollection.updateOne({ _id: baseRevisionData._id }, { $set: updateFieldsForRevision }, { session });
					// Update the main prompt document with new updatedAt and denormalized fields
					await promptsCollection.updateOne(
						{ _id: promptDoc._id },
						{
							$set: {
								updatedAt: now,
								// Denormalize fields from the updated latest revision
								name: updateFieldsForRevision.name,
								appId: updateFieldsForRevision.appId,
								tags: updateFieldsForRevision.tags,
								parentId: updateFieldsForRevision.parentId,
								options: updateFieldsForRevision.options,
							},
						},
						{ session },
					);
					// Construct the full revision data for the return object
					finalRevisionDataForPromptObject = { ...baseRevisionData, ...updateFieldsForRevision } as MongoRevisionDoc;
				}
				// Construct the Prompt object to be returned using the final state of the revision
				resultPrompt = this._toPrompt(promptDoc._id, finalRevisionDataForPromptObject);
			}); // End of session.withTransaction

			if (!resultPrompt) {
				// This case indicates an issue within the transaction logic if resultPrompt isn't set.
				throw new Error('Update transaction completed, but the resulting prompt was not constructed.');
			}
			return resultPrompt;
		} catch (error) {
			logger.error(`Error during updatePrompt for prompt ${promptId}:`, error);
			// Re-throw specific, known errors, or a generic one for other failures
			if (
				error instanceof Error &&
				(error.message.includes('not found') ||
					error.message.includes('not authorized') ||
					error.message.includes('missing') ||
					error.message.includes('Invalid prompt ID format'))
			) {
				throw error;
			}
			throw new Error(`Failed to update prompt ${promptId}. Review logs for details.`);
		} finally {
			await session.endSession();
		}
	}

	async deletePrompt(promptId: string, userId: string): Promise<void> {
		const promptsCollection = this.getPromptsCollection();
		const revisionsCollection = this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format for deletePrompt: ${promptId}. Assuming prompt does not exist.`, error);
			// If ID format is invalid, it's effectively non-existent. Match Firestore's non-erroring behavior.
			return;
		}

		const session = this.client.startSession();
		try {
			await session.withTransaction(async () => {
				// Find the prompt, ensuring it belongs to the user.
				// If not found (either non-existent or not owned by user), promptDoc will be null.
				const promptDoc = await promptsCollection.findOne({ _id: promptObjectId, userId: userId }, { session });

				if (!promptDoc) {
					// If promptDoc is not found for this user, it's either non-existent or belongs to another user.
					// In either case, for this user, it's as if it's deleted or was never there.
					// This matches Firestore's deletePrompt behavior which also doesn't throw if prompt not found.
					logger.warn(`Attempted to delete non-existent prompt ${promptId} or prompt not owned by user ${userId}`);
					return; // Idempotent: if not found or not owned, operation is a no-op for this user.
				}

				// Delete all revisions for this prompt
				// The promptId in MongoRevisionDoc is promptDoc._id (which is an ObjectId)
				await revisionsCollection.deleteMany({ promptId: promptDoc._id }, { session });

				// Delete the main prompt document
				// The _id in MongoPromptDoc is promptDoc._id (which is an ObjectId)
				await promptsCollection.deleteOne({ _id: promptDoc._id }, { session });

				logger.info(`Prompt ${promptId} (ObjectId: ${promptDoc._id.toHexString()}) and its revisions deleted by user ${userId}`);
			});
		} catch (error) {
			logger.error(`Error during deletePrompt for prompt ${promptId}:`, error);
			// Avoid re-throwing generic "Failed to delete prompt" if a specific auth error occurred and was thrown by findOne or similar.
			// However, with the current findOne, an auth issue results in promptDoc being null, which is handled above.
			// So, any error here is likely a transactional or DB operational issue.
			throw new Error(`Failed to delete prompt ${promptId}. Review logs for details. Original error: ${(error as Error).message}`);
		} finally {
			await session.endSession();
		}
	}
}
