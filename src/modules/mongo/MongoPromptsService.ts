import { type Collection, type Db, MongoClient, ObjectId } from 'mongodb';
import { logger } from '#o11y/logger';
import type { PromptsService } from '#prompts/promptsService';
import type { CallSettings, LlmMessage, Prompt, PromptPreview } from '#shared/prompts/prompts.model';

// Interface for the document stored in the 'prompts' collection (main prompt metadata)
interface MongoPromptDoc {
	_id: ObjectId; // Auto-generated by MongoDB, will be used as prompt.id
	userId: string;
	latestRevisionId: number;
	// Denormalized fields from the latest revision for preview (similar to PromptPreview)
	name: string;
	appId?: string | null;
	tags: string[];
	parentId?: string | null;
	options: CallSettings; // Denormalized from latest revision's settings
	createdAt: Date;
	updatedAt: Date;
}

// Interface for the document stored in the 'promptRevisions' collection
interface MongoRevisionDoc {
	_id: ObjectId; // Auto-generated by MongoDB
	promptId: ObjectId; // Foreign key to MongoPromptDoc._id
	revisionId: number;
	userId: string;
	// Revision-specific content
	name: string;
	appId?: string | null;
	tags: string[];
	parentId?: string | null;
	messages: LlmMessage[];
	options: CallSettings; // Actual settings for this revision
	createdAt: Date;
}

export class MongoPromptsService implements PromptsService {
	private client: MongoClient;
	private db: Db | undefined;
	private promptsCollectionName: string;
	private revisionsCollectionName: string;

	constructor() {
		this.client = new MongoClient(process.env.MONGO_URI || 'mongodb://localhost:27017');
		this.promptsCollectionName = 'prompts';
		this.revisionsCollectionName = 'promptRevisions';
	}

	private async getDb(): Promise<Db> {
		// Ensure the client is connected. connect() is idempotent.
		// The driver will also implicitly connect on the first operation.
		// This explicit call ensures the db object is initialized after a connection attempt.
		if (!this.db) {
			await this.client.connect();
			this.db = this.client.db(process.env.MONGO_DB_NAME || 'typedai-dev');
		}
		return this.db;
	}

	private async getPromptsCollection(): Promise<Collection<MongoPromptDoc>> {
		const db = await this.getDb();
		return db.collection<MongoPromptDoc>(this.promptsCollectionName);
	}

	private async getRevisionsCollection(): Promise<Collection<MongoRevisionDoc>> {
		const db = await this.getDb();
		return db.collection<MongoRevisionDoc>(this.revisionsCollectionName);
	}

	private _toPrompt(promptDocIdAsObjectId: ObjectId, revisionDoc: MongoRevisionDoc): Prompt {
		return {
			id: promptDocIdAsObjectId.toHexString(), // Convert ObjectId to string for the Prompt model
			userId: revisionDoc.userId,
			parentId: revisionDoc.parentId === null ? undefined : revisionDoc.parentId,
			revisionId: revisionDoc.revisionId,
			name: revisionDoc.name,
			appId: revisionDoc.appId === null ? undefined : revisionDoc.appId,
			tags: revisionDoc.tags,
			messages: revisionDoc.messages,
			settings: revisionDoc.options,
		};
	}

	async getPrompt(promptId: string, userId: string): Promise<Prompt | null> {
		const promptsCollection = await this.getPromptsCollection();
		const revisionsCollection = await this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format: ${promptId}`, error);
			return null; // Invalid ID format
		}

		const promptDoc = await promptsCollection.findOne({ _id: promptObjectId });

		if (!promptDoc) {
			return null;
		}

		if (promptDoc.userId !== userId) {
			logger.warn(`Unauthorized access attempt for prompt ${promptId} by user ${userId}`);
			return null;
		}

		const revisionDoc = await revisionsCollection.findOne({ promptId: promptDoc._id, revisionId: promptDoc.latestRevisionId });

		if (!revisionDoc) {
			logger.error(`Data inconsistency: Latest revision ${promptDoc.latestRevisionId} for prompt ${promptId} not found.`);
			return null;
		}

		return this._toPrompt(promptDoc._id, revisionDoc);
	}

	private _toPromptPreview(promptDoc: MongoPromptDoc): PromptPreview {
		return {
			id: promptDoc._id.toHexString(),
			userId: promptDoc.userId,
			parentId: promptDoc.parentId === null ? undefined : promptDoc.parentId,
			revisionId: promptDoc.latestRevisionId,
			name: promptDoc.name,
			appId: promptDoc.appId === null ? undefined : promptDoc.appId,
			tags: promptDoc.tags,
			settings: promptDoc.options, // These are denormalized from the latest revision
		};
	}

	async getPrompt(promptId: string, userId: string): Promise<Prompt | null> {
		const promptsCollection = await this.getPromptsCollection();
		const revisionsCollection = await this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format: ${promptId}`, error);
			return null; // Invalid ID format
		}

		const promptDoc = await promptsCollection.findOne({ _id: promptObjectId });

		if (!promptDoc) {
			return null;
		}

		if (promptDoc.userId !== userId) {
			logger.warn(`Unauthorized access attempt for prompt ${promptId} by user ${userId}`);
			return null;
		}

		const revisionDoc = await revisionsCollection.findOne({ promptId: promptDoc._id, revisionId: promptDoc.latestRevisionId });

		if (!revisionDoc) {
			logger.error(`Data inconsistency: Latest revision ${promptDoc.latestRevisionId} for prompt ${promptId} not found.`);
			return null;
		}

		return this._toPrompt(promptDoc._id, revisionDoc);
	}

	async getPromptVersion(promptId: string, revisionId: number, userId: string): Promise<Prompt | null> {
		const promptsCollection = await this.getPromptsCollection();
		const revisionsCollection = await this.getRevisionsCollection();
		let promptObjectId: ObjectId;

		try {
			promptObjectId = new ObjectId(promptId);
		} catch (error) {
			logger.warn(`Invalid promptId format for getPromptVersion: ${promptId}`, error);
			return null;
		}

		const promptDoc = await promptsCollection.findOne({ _id: promptObjectId });

		if (!promptDoc) {
			return null;
		}

		if (promptDoc.userId !== userId) {
			logger.warn(`Unauthorized access attempt for prompt ${promptId} version ${revisionId} by user ${userId}`);
			return null;
		}

		const revisionDoc = await revisionsCollection.findOne({ promptId: promptObjectId, revisionId: revisionId });

		if (!revisionDoc) {
			return null; // Revision not found
		}

		return this._toPrompt(promptDoc._id, revisionDoc);
	}

	async listPromptsForUser(userId: string): Promise<PromptPreview[]> {
		const promptsCollection = await this.getPromptsCollection();
		const promptDocs = await promptsCollection.find({ userId: userId }).sort({ updatedAt: -1 }).toArray();

		if (!promptDocs || promptDocs.length === 0) {
			return [];
		}

		return promptDocs.map(doc => this._toPromptPreview(doc));
	}

	async createPrompt(promptData: Omit<Prompt, 'id' | 'revisionId' | 'userId'>, userId: string): Promise<Prompt> {
		const promptsCollection = await this.getPromptsCollection();
		const revisionsCollection = await this.getRevisionsCollection();
		const newPromptObjectId = new ObjectId();
		const firstRevisionId = 1;
		const now = new Date();

		const mongoPromptDocData: MongoPromptDoc = {
			_id: newPromptObjectId,
			userId: userId,
			latestRevisionId: firstRevisionId,
			name: promptData.name,
			appId: promptData.appId ?? null,
			tags: promptData.tags,
			parentId: promptData.parentId ?? null,
			options: promptData.settings, // Denormalized from first revision
			createdAt: now,
			updatedAt: now,
		};

		const mongoRevisionDocData: MongoRevisionDoc = {
			_id: new ObjectId(), // New ObjectId for the revision doc itself
			promptId: newPromptObjectId,
			revisionId: firstRevisionId,
			userId: userId,
			name: promptData.name,
			appId: promptData.appId ?? null,
			tags: promptData.tags,
			parentId: promptData.parentId ?? null,
			messages: promptData.messages,
			options: promptData.settings,
			createdAt: now,
		};

		await promptsCollection.insertOne(mongoPromptDocData);
		await revisionsCollection.insertOne(mongoRevisionDocData);

		return this._toPrompt(newPromptObjectId, mongoRevisionDocData);
	}

	async updatePrompt(promptId: string, updates: Partial<Omit<Prompt, 'id' | 'userId' | 'revisionId'>>, userId: string, newVersion: boolean): Promise<Prompt> {
		// const collection = await this.getCollection();
		return Promise.reject(new Error('Method not implemented.'));
	}

	async deletePrompt(promptId: string, userId: string): Promise<void> {
		// const collection = await this.getCollection();
		return Promise.reject(new Error('Method not implemented.'));
	}
}
